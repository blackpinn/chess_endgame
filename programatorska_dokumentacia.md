# Chess endgame program - programatorska dokumentacia

# Zvoleny algoritmus
- Program a hlavna logika programu je stavana na ```minimax``` algoritme pomocou ktoreho vieme prechadzat strom hry a vyslednou hodnotou v koreni zistit ci je mozne vynutit mat do troch tahov bielym hracom, hlbka naseho stromu hry je 6 co predstavuje 3 tahy kedze do kazdeho tahu je zaratany pol tah bieleho aj cierneho hraca. Tento strom je teda rekurzivne prehladavany a ak dojdeme do maximalnej hlbky alebo objavime poziciu ktora predstavuje konecny stav hry, poziciu ohodnotime pomocou ohodnocovacej funkcie, ktorej sa budeme podrobnejsie venovat dalej. Implementovany ```minimax``` vyuziva aj ```alfa-beta prerezavanie``` co moze v urcitych pripadoch znizit pocet prehladavanych uzlov a algoritmus tak o nieco urychlit, aj ked pri nasej hlbke troch tahov to vyrazne efektivnost nezlepsi.
# Vyber algoritmu
- Vyber ```minimaxu``` bola priamociara volba, kedze najlepsie sachove enginy vyuzivaju nejaku formu minimaxu aj ked ovela komplexnejsiu takisto co sa ohodnocovacej funkcie tyka, alebo su pouzite neuronove siete, tuto moznost som si samozrejme pre zlozitost implementacie a mojich skusenosti nevybral.
- Takisto je minimax dobre zdokumentovany, prvykrat som sa o nom dopocul na prednaske z Algoritmizace a aj ked som vedel, ze sa nieco taketo na pozadi sachovych enginov deje, nevedel som konkretne detaily, tento projekt mi ho pomohol prebadat a pochopit este podrobnejsie, aj ked ide o jednoduchsiu verziu implementacie.
- Odkaz na video z ktoreho som cerpal inspiraciu, minimax aj v kontexte sachov: [video_link](https://youtu.be/l-hh51ncgDI)
# Program
## Hlavna kniznica a datova struktura
- ```chess.Board```: Je dolezite vyzdvihnut tento objekt ktory reprezentuje aktualny stav sachovnice na zaklade coho stoji cela logika programu, tento objekt je poskytnuty v kniznici ```chess```, ktora pomaha mnoho ulahcujucich funkcii na zistenie pozicie figurok, farby na tahu, ci nastal mat/pat atd... S touto kniznicou som teda pracoval v ramci celeho programu.
## Moduly
- ```parse_input.py```: Tento modul ma za ulohu odchytit nespravne zadany FEN format, v opacnom pripade pomocou triedy ```FENParser``` a jej metody previest vstupny FEN retazec na objekt ```chess.Board```, ktory vracia.
- ```check_board.py```: Obsahuje funkcie, ktore kontroluju ci pozicia na vstupe splna specifikacie koncovky a na zaklade toho varuje uzivatela o konkretnom poruseni specifikacie, poziciu je teda potrebne upravit a zadat znova.
- ```minimax.py```: Ide o implementaciu minimaxu s alfa-beta prerezavanim, ktory je spominany vyssie. Obsahuje funkciu, ktora teda rozhodne o tom ci je mozne vynutit mat do troch tahov.
- ```position_evaluation.py```: Modul ma za ulohu ohodnotit zadanu sachovu poziciu na zaklade toho ci nastal mat, co zavisi aj od toho kto je aktualne na tahu, inak ide o pocet legalnych tahov cierneho krala, ci sa nachadza na okraji sachovnice atd..
- ```main.py```: V tomto module sa nacita uzivatelsky vstup, na vystupne su prvotne obsiahnute strucne informacie o fungovani programu a poziadavky, nasledne su volane vsetky ostatne moduly pomocou ktorych uzivatel obdrzi vystup o vysledku, pripadnej chybe zadania, nedodrzania specifikacie.
- ```endgame_positions_tests.py```: Ide o testovaci modul, ktory testuje hlavnu logiku a overuje schopnost algoritmu detekovat rozne situacie kedy je mat do troch tahov vynutitelny, pripadne aj kedy nie
- ```valid_input_positions_tests.py```: Ide o testovaci modul, ktory zachytava nekorektny FEN format alebo pozicie ktore nesplnuju specifikaciu.
- Komunikacia medzi modulmi prebieha tak, ze najprv ```main.py``` vyuziva ```parse_input.py``` k overeniu fen formatu a vytvoreniu ```chess.Board``` objektu, nasledne je tento objekt predany funkciam z ```check_board.py```, ktore overuju splnenie specifikacie vstupnej pozicie. Ak je vstup validny a pozicia splna specifikaciu je predana modulu ```minimax.py```, ktora pracuje z ohodnocovacov funkciou z ```position_evaluation.py``` takto teda obdrzime vystup/info o tom ci je mat do troch tahov vynutitelny.
## Alternativne programove riesenia
- Program je implementovany modularne, kedze aj ked ide iba o koncovky funkcionalit je ptrebnych pomerne vela a preto by bol inak velmi neprehladny, takisto su takto uprava a vylepsenia do buducna podstatne jednoduchsie. 
- Uzivatelske rozhranie je v nasom programe textove, graficke rozhranie pre specifikaciu programu uplne nedava zmysel, kedze nas zaujima iba informacia o tom ci je alebo nie je mozne vynutit mat do troch tahov. Ak by sme vsak pridali vypisovanie jednotlivych pozicii, ktore k vynutenemu matu vedu, moze byt graficka reprezentacia prehladnejsia pre predstavy uzivatela.
- Rozne vyhodnocovacie funkcie ktore presnejsie vyhodnocuju danu poziciu, pridavanim dalsich podobnych obmedzeni sa presnost/efektivnost vyrazne nezlepsia a inak su vyhodnocovacie funkcie naozaj zlozite, zmysel by mali hlavne ak by koncovka bola zadana komplexnesie a prehladavali by sme napriklad do vacsej hlbky.
# Priebeh prace a zaver
- Projekt som si vybral kedze mam rad sachy a toto prepojenie mi prislo vhodne, takisto islo o naviazanie na uvod do hier s uplnou informaciu,minimaxu atd... Teorii som pochopil a prislo mi to zaujimave, no chcel som si vyskusat teda nieco aj sam naimplementovat, obsiril som si tak chapanie samotnych algoritmov pouzitych pri vykonnych sachovych enginoch, no zaroven som narazil aj na zlozitost nad moje aktualne schopnosti, kedze aj ked ide iba o koncovky, na presne a efektivne vyhodnocovanie pozicii su v realite pouzite velmi zlozite algoritmy, ktore sice suhlasia co sa nacrtu tyka s mojou implementaciou, no ich celkova a spravna implementacia je ovela zlozitejsia. Program je nakoniec vsak funkcny a aj ked ide o jednoduchsiu verziu, ako uvod do tejto problematiky to pre mna bola dobra skusenost.

- Moduly boli vyvyjane samostatne a vzdy ked som narazil na nejaky problem/pripad kedy program nefungoval spravne napisal som pre neho test, tieto testy som potom rozdelil na dve sady ktore sluzia na otestovanie hlavnych dvoch typov problemov(logika,spravnost vstupu), ktore mozu nastat.

